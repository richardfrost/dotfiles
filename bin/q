#!/usr/bin/env ruby -w

require 'optparse'

##
# Example Commands
#
# List all dabases on se-prod-postgres201
# qc pg list se-prod 1
#
# Start a psql session on se-prod-postgres201
# qc pg [psql] se-prod 1
#
# Connect to the rails console on sb-sand-ballista1
# qc app rails sb-sand-ballista
# TODO:
# Connect to the rails console on sb-sand-ballista1
# qc app current rails sb-sand-ballista
# TODO:
# Connect to the rails console on sb-sand-ballista1
# qc app current rails sb-sand-ballista
# TODO: Switch to current on app?
# TODO: mdtail - Maybe open up sshmux to all nodes and execute mdtail?
# TODO: vertica

##
# Todo
#
# Support explicit database hostname instead of just master

# Supported attributes:
# app
# hostname
#
class Command
  def environment
    case @env
    when 'corp'
      'corporate'
    when 'int'
      'integration'
    when 'prod'
      'production'
    when 'qa'
      'qa'
    when 'sand'
      'sandbox'
    end
  end

  def hostname
    "#{@site}-#{@env}-#{@app}#{@node_number}"
  end

  def logs
    "#{ssh} -t 'mdtail || $SHELL -l'"
  end

  def rails
    "#{ssh} -t 'source /etc/profile && cd /srv/#{@app}/current && mdenv bundle exec rails console || $SHELL -l'"
  end

  def run
    puts self.public_send(@command)
    system(self.public_send(@command))
  end

  def ssh
    "ssh -q #{hostname}"
  end

  def tmux
    title = @command.nil? ? "main" : @command
    "#{ssh} -t 'tmux new-session -A -s #{title}'"
  end

  def tmux_rails
    "#{ssh} -t 'tmux new-session -A -s main \"source /etc/profile && cd /srv/#{@app}/current && mdenv bundle exec rails console; bash -l\" || $SHELL -l'"
  end
end

class App < Command
  def initialize(args)
    options = App.parse_quick(args)
    if options
      @command = options.fetch('command', 'ssh')
      @site = options.fetch('site')
      @env = options.fetch('env')
      @app = options.fetch('app')
      @node_number = options.fetch('node_number', 1)
      run
    end
  end

  def self.parse_quick(args)
    options = {}
    args.each do |arg|
      case arg
      when /^(logs|rails|ssh|tmux|tmux_rails)$/i
        options['command'] = arg
      when /^\w{2,}-\w{2,4}-\w+$/
        site_env = arg.split('-')
        options['site'] = site_env[0]
        options['env'] = site_env[1]
        options['app'] = site_env[2].match(/^[a-zA-Z]+/).to_s
        if !!(site_env[2].match(/\d+$/))
          options['node_number'] = site_env[2].match(/\d+$/)
        end
      end
    end

    options if options.has_key?('site') && options.has_key?('env') && options.has_key?('app')
  end
end

class Postgres < Command
  def initialize(args)
    options = Postgres.parse_quick(args)
    if options
      @command = options.fetch('command', 'psql')
      @site = options.fetch('site')
      @env = options.fetch('env')
      @database = options.fetch('database', nil)
      @master = options.fetch('master', false)
      @host_number = options.fetch('host_number', nil)
      run
    end
  end

  def self.parse_quick(args)
    options = {}
    args.each do |arg|
      case arg
      when /^(list|log|psql|tmux)$/i
        options['command'] = arg
      when /^master$/i
        options['master'] = true
      when /^\w{2,}-\w{2,4}$/
        site_env = arg.split('-')
        options['site'] = site_env[0]
        options['env'] = site_env[1]
      when /^\w{3,}$/
        options['database'] = arg
      when /^\d$/
        options['host_number'] = arg
      end
    end

    options if options.has_key?('site') && options.has_key?('env')
  end

  def cluster_number
    case @env
    when 'prod'
      if @host_number
        @host_number
      else
        case @database
        when 'amigo', 'grafana', 'macklin', 'persona', 'vault'
          1
        when 'ballista'
          2
        when 'abacus'
          3
        when 'batcave', 'bullseye', 'dispatch', 'newman', 'sherlock', 'synchronicity' #, 'vault'
          6
        end
      end
    when 'corp', 'int', 'qa', 'sand'
      1
    end
  end

  def full_database
    "#{@database}_#{environment}" if @database
  end

  def hostname
    case @env
    when 'prod'
      if cluster_number
        "#{@site}-#{@env}-postgres#{series_number}#{cluster_number}"
      else
        puts "Error - Couldn't find database cluster from: #{@database}"
        exit
      end
    when 'corp', 'int', 'qa', 'sand'
      "#{@site}-#{@env}-postgres#{series_number}"
    end
  end

  def series_number
    case @env
    when 'corp', 'int', 'qa', 'sand'
      @master ? '101' : '201'
    when 'prod'
      @master ? '10' : '20'
    end
  end

  ##
  # Command components
  #
  def pg_log_dir
    "/var/lib/postgresql/9.5/postgres#{cluster_number}_#{environment}/pg_log"
  end

  def psql_component
    "psql -U postgres -h /var/run/postgresql/9.5/postgres#{cluster_number}_#{environment}/"
  end

  def psql_database
    "-d #{full_database}" if @database
  end

  ##
  # Instance Commands
  #
  def list
    "#{ssh} -t 'echo \"#{hostname}\"; #{psql_component} --list'"
  end

  def log
    "#{ssh} -t 'echo \"#{hostname}\"; sudo su -c \"tail -f #{pg_log_dir}/*\"'"
  end

  def psql
    "#{ssh} -t 'echo \"#{hostname}\n#{psql_component} #{psql_database}\"; #{psql_component} #{psql_database}'"
  end

  def tmux
    "#{ssh} -t 'tmux new-session -A -s psql \"#{psql_component} #{psql_database}; bash -l\" || $SHELL -l'"
  end

  # def ssh_echo_psql
  #   "#{ssh} -t 'echo #{psql} #{psql_database}; $SHELL -l'"
  # end
  #
  # def tmux_command
  #   if @database
  #     "#{ssh} -t '#{tmux} \"echo #{psql} #{psql_database}; #{psql} #{psql_database}; $SHELL -l\" || $SHELL -l'"
  #   else
  #     "#{ssh} -t '#{tmux} \"echo #{psql}; #{psql} #{list}; #{psql}; $SHELL -l\" || $SHELL -l'"
  #   end
  # end
end

class Vertica < Command
  def initialize(args)
    options = Vertica.parse_quick(args)
    puts args
    if options
      @command = options.fetch('command', 'vsql')
      @site = options.fetch('site')
      @env = options.fetch('env')
      @app = 'vertica'
      @database = options.fetch('database', 'ballista')
      @node_number = options.fetch('node_number', 1)
      run
    end
  end

  # Don't require database because there is only one
  def self.parse_quick(args)
    options = {}
    args.each do |arg|
      case arg
      when /^(tmux|vsql)$/i
        options['command'] = arg
      when /^\w{2,}-\w{2,4}$/
        site_env = arg.split('-')
        options['site'] = site_env[0]
        options['env'] = site_env[1]
      when /^\w{3,}$/
        options['database'] = arg
      when /^\d$/
        options['host_number'] = arg
      end
    end

    options if options.has_key?('site') && options.has_key?('env')
  end

  ##
  # Command components
  #
  def vertica_database
    "-d #{@database}_#{environment}"
  end

  def vsql_bin
    "/opt/vertica/bin/vsql"
  end

  ##
  # Instance Commands
  #
  def vsql
    # "#{ssh} -t 'echo \"#{hostname}\"; sudo -i -u dbadmin #{vsql_bin} #{vertica_database}'"
    "#{ssh} -t 'echo \"#{hostname}\"; #{vsql_bin} --user=dbadmin #{vertica_database}'"
  end

  def tmux
    "#{ssh} -t 'tmux new-session -A -s main \"tmux split-window -h sudo -i -u dbadmin bash\" || $SHELL -l'"
  end
end

class QuickConnect
  def initialize(args)
    available_commands = ["app", "pg", "vertica"]
    args.unshift('app') unless available_commands.include? args.first # Default to app
    @command = args.first
    @args = args[1..-1]
  end

  def run
    case @command
    when "app"
      App.new(@args)
    when "pg"
      puts "postgres"
      Postgres.new(@args)
    when "vertica"
      Vertica.new(@args)
    end
  end
end

QuickConnect.new(ARGV).run
